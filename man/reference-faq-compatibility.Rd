% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/faq-developer.R
\name{reference-faq-compatibility}
\alias{reference-faq-compatibility}
\title{FAQ - Is my class compatible with vctrs?}
\description{
vctrs provides a framework for working with vector classes in a generic
way. However, it implements several compatibility fallbacks to base R
methods. In this reference you will find how vctrs tries to be
compatible with your vector class, and what base methods you need to
implement for compatibility.
\subsection{The vctrs primitives}{

Most functions in vctrs are aggregate operations: they call other vctrs
functions which themselves call other vctrs functions. The dependencies
of a vctrs functions are listed in the Dependencies section of its
documentation page. Take a look at \code{\link[=vec_count]{vec_count()}} for
an example.

These dependencies form a tree whose roots are the four vctrs
primitives.
\subsection{The proxy and restoration generics}{
\itemize{
\item \code{\link[=vec_proxy]{vec_proxy()}}
\item \code{\link[=vec_restore]{vec_restore()}}
}

These generics are essential for vctrs but mostly optional.
\code{vec_proxy()} defaults to an \link{identity} function and you
normally donâ€™t need to implement it. The proxy a vector must be one of
the atomic vector types, a list, or a data frame. By default, S3 lists
that do not inherit from \code{"list"} do not have an identity proxy. In that
case, you need to explicitly implement \code{vec_proxy()} or make your class
inherit from list.

\code{vec_restore()} is called is called after manipulating vector proxies,
to restore attributes that might have been lost in the process or that
need to be updated when the contents of a vector have changed. If not
implemented, all attributes are restored by default.
}

\subsection{The coercion generics}{

The coercion mechanism in vctrs is based on two generics:
\itemize{
\item \code{\link[=vec_ptype2]{vec_ptype2()}}
\item \code{\link[=vec_cast]{vec_cast()}}
}

See the \link[=theory-faq-coercion]{theory overview}.

Two objects with the same class and the same attributes are always
considered compatible by ptype2 and cast. If the attributes or classes
differ, they throw an incompatible type error.

Coercion errors are the main source of incompatibility with vctrs. See
the \link[=howto-faq-coercion]{howto guide} if you need to implement methods
for these generics.
}

}

\subsection{Aggregate operations with fallbacks}{

vctrs can achieve all necessary operations on vectors with the four
primitives listed boved. However there are many higher level operations.
The most important ones implement fallbacks to base generics for maximum
compatibility with existing classes.
\itemize{
\item We have started to implement a fallback mechanism in
\code{\link[=vec_cast_common]{vec_cast_common()}}. This function normally
calls \code{\link[=vec_ptype2]{vec_ptype2()}} and
\code{\link[=vec_cast]{vec_cast()}} to normalise a set of inputs to the
same type. When the inputs do not implement the coercion generics
but they all inherit from the same base class, we do not attempt any
coercion and leave the inputs as is.

This fallback should be safe to use before operations like
\code{\link[=vec_match]{vec_match()}} or \code{\link[=vec_rbind]{vec_rbind()}}.
It is currently internal.
\item \code{\link[=vec_slice]{vec_slice()}} falls back to the base \code{[} generic
if no \code{\link[=vec_proxy]{vec_proxy()}} method is implemented. This
way foreign classes that do not implement
\code{\link[=vec_restore]{vec_restore()}} can restore attributes based on
the new subsetted contents.
\item \code{\link[=vec_c]{vec_c()}} falls back to \code{base::c()} if all inputs have
the same class for which a \code{c()} method is implemented but no
self-to-self \code{\link[=vec_ptype2]{vec_ptype2()}} method is
implemented.
}
}
}
